Summary of Changes
-----------------

This project aims to extend RowCache of Cassandra with CAPI-Flash.

By adding a JVM argument, the new CAPI-RowCache is enabled.
All of cached data are stored in large space of http://www-03.ibm.com/systems/storage/flash[IBM FlashSystem]
through high-performance device https://www.ibm.com/developerworks/community/blogs/fe313521-2e95-46f2-817d-44a4f27eba32/entry/power8_capi_flash_in_memory_expansion_to_speed_data_access[CAPI-Flash].

CAPI-Flash
----------

CAPI-Flash provides high throughput and low latency for accessing storage.
With the help of POWER8's http://www-304.ibm.com/webapp/set2/sas/f/capi/home.html[CAPI] (Coherent Accelerator Processor Interface) capability, a CAPI-Flash card can directly access memory that POWER8 processors use.
Thus, data exchanges between memory and storage are simplified and optimized.
In addition, CAPI-Flash doesn't require kernel processing.
No kernel intervention also reduces overheads to access storage.

How to build
------------

CAPI-RowCache depends on capiblock.jar and libcapiblock.so, which are not published yet.
Please contact IBM for these libraries.

OpenJDK 1.7 (or later) is required.

  $ git clone https://github.com/hhorii/cassandra.git #clone this project
  $ cd cassandra #go to the project directory
  $ cp CAPIBLOCK_DIR/capiblock.jar CAPIBLOCK_DIR/libcapiblock.so lib/ #copy the libraries
  $ JAVA_TOOL_OPTIONS=-Dfile.encoding=UTF8 ant #build the project

How to run
----------

To run Cassandra with CAPI-RowCache, the following three configurations are necessary.

 * The LD_LIBRARY_PATH environment variable must include the directory of the CAPI libraries (Usually, the directory is /opt/ibm/capikv/lib).
 * The java.library.path Java property must include the directory of CASSANDRA_HOME/lib to load libcapiblock.so.
 * The following CAPI-RowCache parameters must be set in Java properties.
 ** rowcache.type=capi
 ** capi.cell=GB_FOR_BUCKETS_IN_CACHE
 ** capi.devices=DEVICE_PATH:START_LBA:GB_FOR_CACHE[:DEVICE_PATH[,DEVICE_PATH]][,DEVICE_PATH:START_LBA:GB_FOR_CACHE[:DEVICE_PATH[,DEVICE_PATH]]]
 ** capi.init=true|false
 ** (optional)capi.hash=CLASS_NAME

For the first use of CAPI-RowCache, **capi.init** must be **true** to initialize CAPI-RowCache.

CAPI-RowCache is a simple hash map that has buckets. One bucket contains a key, a value, and a pointer to the next entry with the same [hashkey % #buckets].
One bucket is 4KB and if 4KB is not enough to store a key and a value, they are stored in another space.
**capi.cell** specifies the size of the total buckets. The larger capi.cell will improve performance.

**capi.devices** specifies CAPI-Flash device paths. For example, capi.devices=/dev/sg7:0:512 configures 512GB of /dev/sg7 from LBA 0. 
If /dev/sg8 and /dev/sg9 share the same LBA space with /dev/sg7, you can use them as capi.devices=/dev/sg7:0:512:/dev/sg8:/dev/sg9.
To use multiple CAPI device paths that don't share LBA spaces, you can list them as capi.devices=/dev/sg7:0:512:/dev/sg8:/dev/sg9,/dev/sg15:0:512:/dev/sg16:/dev/sg17.

**capi.hash** optimizes CAPI-RowCache by generating an application-unique cache function.
See https://github.com/hhorii/cassandra/blob/cassandra-2.1-capirowcache/src/java/org/apache/cassandra/cache/capi/YCSBKeyHashFunction.java[YCSBKeyHashFunction.java] for an example for YCSB.

Example to run YCSB with CAPI-RowCache
--------------------------------------

Here is an example of a command to start Cassandra with 512GB (256GB for buckets) for YCSB.

  $ cd $CASSANDRA_HOME
  $ vi conf/cassandra.yaml
  $ # set few hundreds bytes (such as 128MB) to row_cache_size_in_mb as "row_cache_size_in_mb: 128".
  $ LD_LIBRARY_PATH=/opt/ibm/capikv/lib JVM_OPTS="-Djava.library.path=lib/ \
    -Drowcache.type=capi -Dcapi.devices=/dev/sg7:0:512 -Dcapi.cell=256 -Dcapi.init=true \
    -Dcapi.hash=org.apache.cassandra.cache.capi.YCSBKeyHashFunction" \
    bin/cassandra #start with CAPI-RowCache
  $ $CASSANDRA_HOME/bin/cqlsh << EOF
      CREATE KEYSPACE usertable WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : 1 };
      USE usertable;
      CREATE TABLE data (
        key blob,
        column1 blob,
        value blob,
        PRIMARY KEY ((key), column1)
      ) WITH COMPACT STORAGE AND
        bloom_filter_fp_chance=0.010000 AND
        caching='ALL' AND
        comment='' AND
        dclocal_read_repair_chance=0.100000 AND
        gc_grace_seconds=864000 AND
        index_interval=128 AND
        read_repair_chance=0.000000 AND
        replicate_on_write='true' AND
        populate_io_cache_on_flush='false' AND
        default_time_to_live=0 AND
        speculative_retry='NONE' AND
        memtable_flush_period_in_ms=0 AND
        compaction={'class': 'SizeTieredCompactionStrategy'} AND
        compression={'sstable_compression': 'LZ4Compressor'};
    EOF
  $ wget https://github.com/brianfrankcooper/YCSB/releases/download/0.7.0/ycsb-0.7.0.tar.gz
  $ tar zxvf ycsb-0.7.0.tar.gz
  $ cd ycsb-0.7.0/
  $ ./bin/ycsb load cassandra-10 -P workloads/workloadc -p "hosts=localhost" -p "insertorder=ordered" -s
  $ ./bin/ycsb run cassandra-10 -P workloads/workloadc -p "hosts=localhost" \
    -p "operationcount=1000000" -p "requestdistribution=uniform" -threads 64 -s
  
Tips for tuning Cassandra on IBM POWER8
---------------------------------------
Most of the performance tuning techniques effective on x86 can apply to POWER8 as well.
Since POWER8 supports up to SMT8 (Simultaneous Multi-Threading of 8 threads per core),
while x86 does SMT2, you might want to increase concurrent_reads, concurrent_writes,
and memtable_flush_writers in cassandra.yaml in order to take advantage of
the many threads supported by the hardware. As far as YCSB is concerned,
SMT8 is better than SMT4 or SMT2.

Linux on POWER uses 64-KB pages by default, while Linux on x86 does 4-KB pages.
Without CAPI-Flash, Cassandra reads and writes data on disks through the OS page cache,
which is managed on a per-page basis. This means that the unit of a read or write operation
is the page size, and thus the page size can affect Cassandra's I/O performance.
The 64-KB pages of POWER are suitable for sequential I/O, but if your Cassandra application
requires a lot of random reads from SSTables on disks and if the size of each read is small
(say, 1 KB), then the 64-KB pages can hurt the performance.
In this case, you can reconfigure the Linux kernel to use 4-KB pages on POWER.
