Summary of Changes
-----------------

This project aims to extend RowCache of Cassandra with CAPI-Flash.

By adding a JVM argument, the new CAPI-RowCache is enabled.
All of cached data are stored in large space of http://www-03.ibm.com/systems/storage/flash[IBM FlashSystem]
through high-performance device https://www.ibm.com/developerworks/community/blogs/fe313521-2e95-46f2-817d-44a4f27eba32/entry/power8_capi_flash_in_memory_expansion_to_speed_data_access[CAPI-Flash].

CAPI-Flash
----------

CAPI-Flash provides high throughput and low latency for accessing storage.
With the help of POWER8's http://www-304.ibm.com/webapp/set2/sas/f/capi/home.html[CAPI] (Coherent Accelerator Processor Interface) capability, a CAPI-Flash card can directly access memory that POWER8 processors use.
Thus, data exchanges between memory and storage are simplified and optimized.
In addition, CAPI-Flash doesn't require kernel processing.
No kernel intervention also reduces overheads to access storage.

How to build
------------

CAPI-RowCache depends on capiblock.jar and libcapiblock.so, which are not published yet.
Please contact IBM for these libraries.

OpenJDK 1.7 (or later) is required.

  $ git clone https://github.com/hhorii/cassandra.git #clone this project
  $ cd cassandra #go to the project directory
  $ cp CAPIBLOCK_DIR/capiblock.jar CAPIBLOCK_DIR/libcapiblock.so lib/ #copy the libraries
  $ JAVA_TOOL_OPTIONS=-Dfile.encoding=UTF8 ant #build the project

How to run
----------

To run Cassandra with CAPI-RowCache, the following three configurations are necessary.

 * The LD_LIBRARY_PATH environment variable must include the directory of the CAPI libraries (Usually, the directory is /opt/ibm/capikv/lib).
 * The java.library.path Java property must include the directory of CASSANDRA_HOME/lib to load libcapiblock.so.
 * The following CAPI-RowCache parameters must be set in Java properties.
 ** rowcache.type=capi
 ** capi.cell=GB_FOR_BUCKETS_IN_CACHE
 ** capi.devices=DEVICE_PATH:START_LBA:GB_FOR_CACHE[:DEVICE_PATH[,DEVICE_PATH]][,DEVICE_PATH:START_LBA:GB_FOR_CACHE[:DEVICE_PATH[,DEVICE_PATH]]]
 ** capi.init=true|false
 ** (optional)capi.hash=CLASS_NAME

For the first use of CAPI-RowCache, **capi.init** must be **true** to initialize CAPI-RowCache.

CAPI-RowCache is a simple hash map that has buckets. One bucket contains a key, a value, and a pointer to the next entry with the same [hashkey % #buckets].
One bucket is 4KB and if 4KB is not enough to store a key and a value, they are stored in another space.
**capi.cell** specifies the size of the total buckets. The larger capi.cell will improve performance.

**capi.devices** specifies CAPI-Flash device paths. For example, capi.devices=/dev/sg7:0:512 configures 512GB of /dev/sg7 from LBA 0. 
If /dev/sg8 and /dev/sg9 share the same LBA space with /dev/sg7, you can use them as capi.devices=/dev/sg7:0:512:/dev/sg8:/dev/sg9.
To use multiple CAPI device paths that don't share LBA spaces, you can list them as capi.devices=/dev/sg7:0:512:/dev/sg8:/dev/sg9,/dev/sg15:0:512:/dev/sg16:/dev/sg17.

**capi.hash** optimizes CAPI-RowCache by generating an application-unique cache function.
See https://github.com/hhorii/cassandra/blob/cassandra-2.1-capirowcache/src/java/org/apache/cassandra/cache/capi/YCSBKeyHashFunction.java[YCSBKeyHashFunction.java] for an example for YCSB.

Example to run YCSB with CAPI-RowCache
--------------------------------------

Here is an example of a command to start Cassandra with 512GB (256GB for buckets) for YCSB.

  $ cd $CASSANDRA_HOME
  $ LD_LIBRARY_PATH=/opt/ibm/capikv/lib JVM_OPTS="-Djava.library.path=lib/ \
    -Drowcache.type=capi -Dcapi.devices=/dev/sg7:0:512 -Dcapi.cell=256 -Dcapi.init=true \
    -Dcapi.hash=org.apache.cassandra.cache.capi.YCSBKeyHashFunction" \
    $CASSANDRA_HOME/bin/cassandra #start with CAPI-RowCache
